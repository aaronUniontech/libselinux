Index: libselinux/src/getfilecon.c
===================================================================
--- libselinux.orig/src/getfilecon.c
+++ libselinux/src/getfilecon.c
@@ -69,3 +69,64 @@ int getfilecon(const char *path, char **
 	return ret;
 }
 
+int usec_getfilecon_raw(const char *path, const char* attr_name, char ** context)
+{
+	char *buf;
+	ssize_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = getxattr(path, attr_name, buf, size - 1);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		size = getxattr(path, attr_name, NULL, 0);
+		if (size < 0)
+			goto out;
+
+		size++;
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = getxattr(path, attr_name, buf, size - 1);
+	}
+      out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = ENOTSUP;
+		ret = -1;
+	}
+	if (ret < 0)
+		free(buf);
+    else if (strcmp(attr_name, XATTR_NAME_USEC_USER) == 0 || strcmp(attr_name, XATTR_NAME_USEC_SMODEL) == 0) {
+        unsigned int val = *((unsigned int *)buf);
+        free(buf);
+        *context = malloc(11);
+        snprintf(*context, 10, "0x%8x", val);
+        ret = 11;
+    }
+	else
+		*context = buf;
+	return ret;
+}
+
+int usec_getfilecon(const char *path, const char* attr_name, char** context)
+{
+	int ret;
+	*context = NULL;
+
+	ret = usec_getfilecon_raw(path, attr_name, context);
+
+	if (ret >= 0 && *context)
+		return strlen(*context) + 1;
+
+	return ret;
+}
\ No newline at end of file
Index: libselinux/src/label_file.h
===================================================================
--- libselinux.orig/src/label_file.h
+++ libselinux/src/label_file.h
@@ -532,6 +532,10 @@ static inline int process_line(struct se
 	 * any meta characters in the RE */
 	spec_hasMetaChars(&spec_arr[nspec]);
 
+	// usec user context, like 0xfffffff
+	if (strncasecmp(context, "0x", 2) == 0)
+		return 0;
+
 	if (strcmp(context, "<<none>>") && rec->validating)
 		return compat_validate(rec, &spec_arr[nspec].lr, path, lineno);
 
Index: libselinux/src/lgetfilecon.c
===================================================================
--- libselinux.orig/src/lgetfilecon.c
+++ libselinux/src/lgetfilecon.c
@@ -49,6 +49,57 @@ int lgetfilecon_raw(const char *path, ch
 	return ret;
 }
 
+int usec_lgetfilecon_raw(const char *path, const char* attr_name, char** con)
+{
+	char *buf;
+	ssize_t size;
+	ssize_t ret;
+
+	size = INITCONTEXTLEN + 1;
+	buf = malloc(size);
+	if (!buf)
+		return -1;
+	memset(buf, 0, size);
+
+	ret = lgetxattr(path, attr_name, buf, size - 1);
+	if (ret < 0 && errno == ERANGE) {
+		char *newbuf;
+
+		size = lgetxattr(path, XATTR_NAME_SELINUX, NULL, 0);
+		if (size < 0)
+			goto out;
+
+		size++;
+		newbuf = realloc(buf, size);
+		if (!newbuf)
+			goto out;
+
+		buf = newbuf;
+		memset(buf, 0, size);
+		ret = lgetxattr(path, XATTR_NAME_SELINUX, buf, size - 1);
+	}
+
+	out:
+	if (ret == 0) {
+		/* Re-map empty attribute values to errors. */
+		errno = ENOTSUP;
+		ret = -1;
+	}
+
+	if (ret < 0)
+		free(buf);
+	else if (strcmp(attr_name, XATTR_NAME_USEC_USER) == 0 || strcmp(attr_name, XATTR_NAME_USEC_SMODEL) == 0) {
+		unsigned int val = *((unsigned int *)buf);
+		free(buf);
+		*con = malloc(12);
+		snprintf(*con, 11, "0x%x", val);
+		ret = strlen(*con) + 1;
+	}
+	else
+		*con = buf;
+
+	return ret;
+}
 
 int lgetfilecon(const char *path, char ** context)
 {
@@ -66,5 +117,17 @@ int lgetfilecon(const char *path, char *
 
 	if (ret >= 0 && *context)
 		return strlen(*context) + 1;
+	return ret;
+}
+
+int usec_lgetfilecon(const char *path, const char* attr_name, char** context)
+{
+	int ret;
+	*context = NULL;
+
+	ret = usec_lgetfilecon_raw(path, attr_name, context);
+
+	if (ret >= 0 && *context)
+		return strlen(*context) + 1;
 	return ret;
 }
Index: libselinux/src/libselinux.map
===================================================================
--- libselinux.orig/src/libselinux.map
+++ libselinux/src/libselinux.map
@@ -285,4 +285,10 @@ LIBSELINUX_3.5 {
     set_usecmnt;
     usecfs_exists;
     fini_usecmnt;
+    usec_getfilecon;
+    usec_lgetfilecon;
+    usec_user_getcon;
+    usec_restorecon_parallel;
+    usec_lsetfilecon_raw;
+    usec_lgetfilecon_raw;
 } LIBSELINUX_3.4;
Index: libselinux/src/lsetfilecon.c
===================================================================
--- libselinux.orig/src/lsetfilecon.c
+++ libselinux/src/lsetfilecon.c
@@ -25,6 +25,69 @@ int lsetfilecon_raw(const char *path, co
 	return rc;
 }
 
+static int charPtrToUint32(const char* str, unsigned int *value) {
+    if (str == NULL) {
+        return -1;
+    }
+    long longValue = 0;
+    char* endptr;
+    if (strncmp(str, "0x", 2) == 0 || strncmp(str, "0X", 2) == 0)
+        longValue = strtoull(str + 2, &endptr, 16);
+    else
+        longValue = strtoull(str, &endptr, 10);
+
+    if (endptr == str) {
+        return -EINVAL;
+    }
+
+    if (*endptr != '\0') {
+        return -EINVAL;
+    }
+
+    if (errno == ERANGE || longValue > 0xffffffff) {
+        return -EINVAL;
+    }
+
+    *value = (unsigned int)longValue;
+    return 0;
+}
+
+int usec_lsetfilecon_raw(const char *path, const char* attr_name, const char* context)
+{
+    int rc = 0;
+    unsigned int value = 0;
+    if (strcmp(attr_name, XATTR_NAME_USEC_USER) == 0 || strcmp(attr_name, XATTR_NAME_USEC_SMODEL) == 0) {
+        if (charPtrToUint32(context, &value) == 0) {
+            rc = lsetxattr(path, attr_name, &value, sizeof(value), 0);
+        }
+    } else {
+	    rc = lsetxattr(path, attr_name, context, strlen(context) + 1, 0);
+    }
+
+	if (rc < 0 && errno == ENOTSUP) {
+		char * ccontext = NULL;
+		int err = errno;
+		if ((usec_lgetfilecon_raw(path, attr_name, &ccontext) >= 0)) {
+            if (strcmp(context, XATTR_NAME_USEC_USER) == 0 || strcmp(context, XATTR_NAME_USEC_SMODEL) == 0) {
+                unsigned int cur_value;
+                if (charPtrToUint32(ccontext, &cur_value) == 0) {
+                    if (cur_value == value)
+                        rc = 0;
+                }
+            }
+            else if (strcmp(context,ccontext) == 0) {
+			    rc = 0;
+            }
+		}
+
+        freecon(ccontext);
+        if (rc < 0) {
+			errno = err;
+		}
+	}
+
+	return rc;
+}
 
 int lsetfilecon(const char *path, const char *context)
 {
Index: libselinux/src/matchpathcon.c
===================================================================
--- libselinux.orig/src/matchpathcon.c
+++ libselinux/src/matchpathcon.c
@@ -46,6 +46,8 @@ int compat_validate(struct selabel_handl
 		rc = myinvalidcon(path, lineno, *ctx);
 	else if (mycanoncon)
 		rc = mycanoncon(path, lineno, ctx);
+	if (strncasecmp(*ctx, "0x", 2) == 0)
+		rc = 0;
 	else {
 		rc = selabel_validate(rec, contexts);
 		if (rc < 0) {
Index: libselinux/src/policy.h
===================================================================
--- libselinux.orig/src/policy.h
+++ libselinux/src/policy.h
@@ -11,6 +11,9 @@
 #define XATTR_NAME_SELINUX "security.selinux"
 #endif
 
+#define XATTR_NAME_USEC_USER "security.usec_user"
+#define XATTR_NAME_USEC_SMODEL "security.usec_smodel"
+
 /* Initial length guess for getting contexts. */
 #define INITCONTEXTLEN 255
 
Index: libselinux/src/procattr.c
===================================================================
--- libselinux.orig/src/procattr.c
+++ libselinux/src/procattr.c
@@ -283,6 +283,26 @@ all_selfattr_def(con, "current", prev_cu
     all_selfattr_def(sockcreatecon, "sockcreate", prev_sockcreate)
     all_selfattr_def(keycreatecon, "keycreate", prev_keycreate)
 
+int usec_user_getcon(unsigned int* con)
+{
+    size_t len;
+    int fd;
+
+    *con = 0;
+    fd = open("/proc/self/attr/usec/ubits", O_RDONLY);
+    if (fd == -1) {
+        return -1;
+    }
+
+    len = read(fd, con, sizeof(*con));
+    close(fd);
+    if (len == -1) {
+        return -1;
+    }
+
+    return 0;
+}
+
 int getpidcon_raw(pid_t pid, char **c)
 {
 	if (pid <= 0) {
Index: libselinux/src/selinux_restorecon.c
===================================================================
--- libselinux.orig/src/selinux_restorecon.c
+++ libselinux/src/selinux_restorecon.c
@@ -47,6 +47,7 @@ static struct selabel_handle *fc_sehandl
 static bool selabel_no_digest;
 static char *rootpath = NULL;
 static size_t rootpathlen;
+static char* usec_attrname = NULL;
 
 /* Information on excluded fs and directories. */
 struct edir {
@@ -802,6 +803,200 @@ err:
 	goto out1;
 }
 
+static int charPtrToUint32(const char* str, unsigned int *value) {
+    if (str == NULL) {
+        return -1;
+    }
+    long longValue = 0;
+    char* endptr;
+    if (strncmp(str, "0x", 2) == 0 || strncmp(str, "0X", 2) == 0)
+        longValue = strtoull(str + 2, &endptr, 16);
+    else
+        longValue = strtoull(str, &endptr, 10);
+
+    if (endptr == str) {
+        return -EINVAL;
+    }
+
+    if (*endptr != '\0') {
+        return -EINVAL;
+    }
+
+    if (errno == ERANGE || longValue > 0xffffffff) {
+        return -EINVAL;
+    }
+
+    *value = (unsigned int)longValue;
+    return 0;
+}
+
+
+static int usec_restorecon_sb(const char *pathname, const struct stat *sb,
+			    const struct rest_flags *flags, bool first, const char* attr_name)
+{
+	char *newcon = NULL;
+	char *curcon = NULL;
+	char *newtypecon = NULL;
+	int rc;
+	const char *lookup_path = pathname;
+	bool is_same = false;
+
+	if (rootpath) {
+		if (strncmp(rootpath, lookup_path, rootpathlen) != 0) {
+			selinux_log(SELINUX_ERROR,
+				    "%s is not located in alt_rootpath %s\n",
+				    lookup_path, rootpath);
+			return -1;
+		}
+		lookup_path += rootpathlen;
+	}
+
+	if (rootpath != NULL && lookup_path[0] == '\0')
+		/* this is actually the root dir of the alt root. */
+		rc = selabel_lookup_raw(fc_sehandle, &newcon, "/",
+						    sb->st_mode & S_IFMT);
+	else
+		rc = selabel_lookup_raw(fc_sehandle, &newcon, lookup_path,
+						    sb->st_mode & S_IFMT);
+
+	if (rc < 0) {
+		if (errno == ENOENT) {
+			if (flags->warnonnomatch && first)
+				selinux_log(SELINUX_INFO,
+					    "Warning no default label for %s\n",
+					    lookup_path);
+
+			return 0; /* no match, but not an error */
+		}
+
+		return -1;
+	}
+
+	if (flags->progress) {
+		__pthread_mutex_lock(&progress_mutex);
+		fc_count++;
+		if (fc_count % STAR_COUNT == 0) {
+			if (flags->mass_relabel && efile_count > 0) {
+				float pc = (fc_count < efile_count) ? (100.0 *
+					     fc_count / efile_count) : 100;
+				fprintf(stdout, "\r%-.1f%%", (double)pc);
+			} else {
+				fprintf(stdout, "\r%" PRIu64 "k", fc_count / STAR_COUNT);
+			}
+			fflush(stdout);
+		}
+		__pthread_mutex_unlock(&progress_mutex);
+	}
+
+	if (flags->add_assoc) {
+		rc = filespec_add(sb->st_ino, newcon, pathname, flags);
+
+		if (rc < 0) {
+			selinux_log(SELINUX_ERROR,
+				    "filespec_add error: %s\n", pathname);
+			freecon(newcon);
+			return -1;
+		}
+
+		if (rc > 0) {
+			/* Already an association and it took precedence. */
+			freecon(newcon);
+			return 0;
+		}
+	}
+
+	if (flags->log_matches)
+		selinux_log(SELINUX_INFO, "%s matched by %s\n",
+			    pathname, newcon);
+
+	if (usec_lgetfilecon_raw(pathname, attr_name, &curcon) < 0) {
+		if (errno != ENODATA)
+			goto err;
+
+		curcon = NULL;
+	}
+
+    if (curcon != NULL) {
+        if (strcmp(attr_name, "security.usec_user") == 0 || strcmp(attr_name, "security.usec_smodel") == 0) {
+            unsigned int cur_value;
+            unsigned int new_value;
+            if (!charPtrToUint32(curcon, &cur_value)) {
+                if ( charPtrToUint32(newcon, &new_value)) {
+                    is_same = (cur_value == new_value);
+                }
+            }
+        } else {
+            is_same = (strcmp(curcon, newcon) == 0);
+        }
+    }
+
+	if (!is_same) {
+		bool updated = false;
+
+		if (!flags->nochange) {
+			int old_flags = 0;
+			int iattr_flag = 0;
+			int fd = open(pathname, O_RDONLY|O_NONBLOCK);
+			if (fd > 0) {
+				if (ioctl(fd, FS_IOC_GETFLAGS, &old_flags) == -1) {
+					close(fd);
+					fd = 0;
+					goto endioctl;
+				}
+
+				if (old_flags & FS_IMMUTABLE_FL) {
+					iattr_flag = 1;
+					old_flags &= ~FS_IMMUTABLE_FL;
+					ioctl(fd, FS_IOC_SETFLAGS, &old_flags);
+				}
+			}
+		endioctl:
+			rc = usec_lsetfilecon_raw(pathname, attr_name, newcon);
+			if (fd > 0) {
+				if (iattr_flag == 1) {
+					old_flags |= FS_IMMUTABLE_FL;
+					ioctl(fd, FS_IOC_SETFLAGS, &old_flags);
+				}
+				close(fd);
+			}
+			if (rc < 0)
+				goto err;
+			updated = true;
+		}
+
+		if (flags->verbose)
+			selinux_log(SELINUX_INFO,
+				    "%s %s from %s to %s\n",
+				    updated ? "Relabeled" : "Would relabel",
+				    pathname,
+				    curcon ? curcon : "<no context>",
+				    newcon);
+
+		if (flags->syslog_changes && !flags->nochange) {
+			if (curcon)
+				syslog(LOG_INFO,
+					    "relabeling %s from %s to %s\n",
+					    pathname, curcon, newcon);
+			else
+				syslog(LOG_INFO, "labeling %s to %s\n",
+					    pathname, newcon);
+		}
+	}
+
+out:
+	rc = 0;
+out1:
+	freecon(curcon);
+	freecon(newcon);
+	return rc;
+err:
+	selinux_log(SELINUX_ERROR,
+		    "Could not set context for %s:  %m\n",
+		    pathname);
+	rc = -1;
+	goto out1;
+}
+
 struct dir_hash_node {
 	char *path;
 	uint8_t digest[SHA1_HASH_SIZE];
@@ -1033,6 +1228,158 @@ unlock:
 	return NULL;
 }
 
+static void *usec_restorecon_thread(void *arg)
+{
+	struct rest_state *state = arg;
+	FTS *fts = state->fts;
+	FTSENT *ftsent;
+	int error;
+	char ent_path[PATH_MAX];
+	struct stat ent_st;
+	bool first = false;
+
+	if (state->parallel)
+		pthread_mutex_lock(&state->mutex);
+
+	if (state->ftsent_first) {
+		ftsent = state->ftsent_first;
+		state->ftsent_first = NULL;
+		first = true;
+		goto loop_body;
+	}
+
+	while (((void)(errno = 0), ftsent = fts_read(fts)) != NULL) {
+loop_body:
+		/* If the FTS_XDEV flag is set and the device is different */
+		if (state->flags.set_xdev &&
+		    ftsent->fts_statp->st_dev != state->dev_num)
+			continue;
+
+		switch (ftsent->fts_info) {
+		case FTS_DC:
+			selinux_log(SELINUX_ERROR,
+				    "Directory cycle on %s.\n",
+				    ftsent->fts_path);
+			errno = ELOOP;
+			state->error = -1;
+			state->abort = true;
+			goto finish;
+		case FTS_DP:
+			continue;
+		case FTS_DNR:
+			error = errno;
+			errno = ftsent->fts_errno;
+			selinux_log(SELINUX_ERROR,
+				    "Could not read %s: %m.\n",
+				    ftsent->fts_path);
+			errno = error;
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_NS:
+			error = errno;
+			errno = ftsent->fts_errno;
+			selinux_log(SELINUX_ERROR,
+				    "Could not stat %s: %m.\n",
+				    ftsent->fts_path);
+			errno = error;
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_ERR:
+			error = errno;
+			errno = ftsent->fts_errno;
+			selinux_log(SELINUX_ERROR,
+				    "Error on %s: %m.\n",
+				    ftsent->fts_path);
+			errno = error;
+			fts_set(fts, ftsent, FTS_SKIP);
+			continue;
+		case FTS_D:
+			if (state->sfsb.f_type == SYSFS_MAGIC &&
+			    !selabel_partial_match(fc_sehandle,
+			    ftsent->fts_path)) {
+				fts_set(fts, ftsent, FTS_SKIP);
+				continue;
+			}
+
+			if (check_excluded(ftsent->fts_path)) {
+				fts_set(fts, ftsent, FTS_SKIP);
+				continue;
+			}
+
+			if (state->setrestorecondigest) {
+				struct dir_hash_node *new_node = NULL;
+
+				if (check_context_match_for_dir(ftsent->fts_path,
+								&new_node,
+								state->error) &&
+								!state->ignore_digest) {
+					selinux_log(SELINUX_INFO,
+						"Skipping restorecon on directory(%s)\n",
+						    ftsent->fts_path);
+					fts_set(fts, ftsent, FTS_SKIP);
+					continue;
+				}
+
+				if (new_node && !state->error) {
+					if (!state->current) {
+						state->current = new_node;
+						state->head = state->current;
+					} else {
+						state->current->next = new_node;
+						state->current = new_node;
+					}
+				}
+			}
+			/* fall through */
+		default:
+			if (strlcpy(ent_path, ftsent->fts_path, sizeof(ent_path)) >= sizeof(ent_path)) {
+				selinux_log(SELINUX_ERROR,
+					    "Path name too long on %s.\n",
+					    ftsent->fts_path);
+				errno = ENAMETOOLONG;
+				state->error = -1;
+				state->abort = true;
+				goto finish;
+			}
+
+			ent_st = *ftsent->fts_statp;
+			if (state->parallel)
+				pthread_mutex_unlock(&state->mutex);
+
+			error = usec_restorecon_sb(ent_path, &ent_st, &state->flags,
+					      first, usec_attrname);
+
+			if (state->parallel) {
+				pthread_mutex_lock(&state->mutex);
+				if (state->abort)
+					goto unlock;
+			}
+
+			first = false;
+			if (error) {
+				if (state->flags.abort_on_error) {
+					state->error = error;
+					state->abort = true;
+					goto finish;
+				}
+				if (state->flags.count_errors)
+					state->skipped_errors++;
+				else
+					state->error = error;
+			}
+			break;
+		}
+	}
+
+finish:
+	if (!state->saved_errno)
+		state->saved_errno = errno;
+unlock:
+	if (state->parallel)
+		pthread_mutex_unlock(&state->mutex);
+	return NULL;
+}
+
 static int selinux_restorecon_common(const char *pathname_orig,
 				     unsigned int restorecon_flags,
 				     size_t nthreads)
@@ -1366,6 +1713,341 @@ fts_err:
 	goto cleanup;
 }
 
+static int usec_restorecon_common(const char *pathname_orig,
+				     unsigned int restorecon_flags,
+				     size_t nthreads, const char* attr_name)
+{
+	struct rest_state state;
+
+	state.flags.nochange = (restorecon_flags &
+		    SELINUX_RESTORECON_NOCHANGE) ? true : false;
+	state.flags.verbose = (restorecon_flags &
+		    SELINUX_RESTORECON_VERBOSE) ? true : false;
+	state.flags.progress = (restorecon_flags &
+		    SELINUX_RESTORECON_PROGRESS) ? true : false;
+	state.flags.mass_relabel = (restorecon_flags &
+		    SELINUX_RESTORECON_MASS_RELABEL) ? true : false;
+	state.flags.recurse = (restorecon_flags &
+		    SELINUX_RESTORECON_RECURSE) ? true : false;
+	state.flags.set_specctx = (restorecon_flags &
+		    SELINUX_RESTORECON_SET_SPECFILE_CTX) ? true : false;
+	state.flags.userealpath = (restorecon_flags &
+		   SELINUX_RESTORECON_REALPATH) ? true : false;
+	state.flags.set_xdev = (restorecon_flags &
+		   SELINUX_RESTORECON_XDEV) ? true : false;
+	state.flags.add_assoc = (restorecon_flags &
+		   SELINUX_RESTORECON_ADD_ASSOC) ? true : false;
+	state.flags.abort_on_error = (restorecon_flags &
+		   SELINUX_RESTORECON_ABORT_ON_ERROR) ? true : false;
+	state.flags.syslog_changes = (restorecon_flags &
+		   SELINUX_RESTORECON_SYSLOG_CHANGES) ? true : false;
+	state.flags.log_matches = (restorecon_flags &
+		   SELINUX_RESTORECON_LOG_MATCHES) ? true : false;
+	state.flags.ignore_noent = (restorecon_flags &
+		   SELINUX_RESTORECON_IGNORE_NOENTRY) ? true : false;
+	state.flags.warnonnomatch = true;
+	state.flags.conflicterror = (restorecon_flags &
+		   SELINUX_RESTORECON_CONFLICT_ERROR) ? true : false;
+	ignore_mounts = (restorecon_flags &
+		   SELINUX_RESTORECON_IGNORE_MOUNTS) ? true : false;
+	state.ignore_digest = (restorecon_flags &
+		    SELINUX_RESTORECON_IGNORE_DIGEST) ? true : false;
+	state.flags.count_errors = (restorecon_flags &
+		    SELINUX_RESTORECON_COUNT_ERRORS) ? true : false;
+	state.setrestorecondigest = true;
+
+	state.head = NULL;
+	state.current = NULL;
+	state.abort = false;
+	state.error = 0;
+	state.skipped_errors = 0;
+	state.saved_errno = 0;
+
+	struct stat sb;
+	char *pathname = NULL, *pathdnamer = NULL, *pathdname, *pathbname;
+	char *paths[2] = { NULL, NULL };
+	int fts_flags, error;
+	struct dir_hash_node *current = NULL;
+
+	usec_attrname = attr_name;
+
+	if (state.flags.verbose && state.flags.progress)
+		state.flags.verbose = false;
+
+	__selinux_once(fc_once, restorecon_init);
+
+	if (!fc_sehandle)
+		return -1;
+
+	/*
+	 * If selabel_no_digest = true then no digest has been requested by
+	 * an external selabel_open(3) call.
+	 */
+	if (selabel_no_digest ||
+	    (restorecon_flags & SELINUX_RESTORECON_SKIP_DIGEST))
+		state.setrestorecondigest = false;
+
+	if (!__pthread_supported) {
+		if (nthreads != 1) {
+			nthreads = 1;
+			selinux_log(SELINUX_WARNING,
+				"Threading functionality not available, falling back to 1 thread.");
+		}
+	} else if (nthreads == 0) {
+		long nproc = sysconf(_SC_NPROCESSORS_ONLN);
+
+		if (nproc > 0) {
+			nthreads = nproc;
+		} else {
+			nthreads = 1;
+			selinux_log(SELINUX_WARNING,
+				"Unable to detect CPU count, falling back to 1 thread.");
+		}
+	}
+
+	/*
+	 * Convert passed-in pathname to canonical pathname by resolving
+	 * realpath of containing dir, then appending last component name.
+	 */
+	if (state.flags.userealpath) {
+		char *basename_cpy = strdup(pathname_orig);
+		if (!basename_cpy)
+			goto realpatherr;
+		pathbname = basename(basename_cpy);
+		if (!strcmp(pathbname, "/") || !strcmp(pathbname, ".") ||
+					    !strcmp(pathbname, "..")) {
+			pathname = realpath(pathname_orig, NULL);
+			if (!pathname) {
+				free(basename_cpy);
+				/* missing parent directory */
+				if (state.flags.ignore_noent && errno == ENOENT) {
+					return 0;
+				}
+				goto realpatherr;
+			}
+		} else {
+			char *dirname_cpy = strdup(pathname_orig);
+			if (!dirname_cpy) {
+				free(basename_cpy);
+				goto realpatherr;
+			}
+			pathdname = dirname(dirname_cpy);
+			pathdnamer = realpath(pathdname, NULL);
+			free(dirname_cpy);
+			if (!pathdnamer) {
+				free(basename_cpy);
+				if (state.flags.ignore_noent && errno == ENOENT) {
+					return 0;
+				}
+				goto realpatherr;
+			}
+			if (!strcmp(pathdnamer, "/"))
+				error = asprintf(&pathname, "/%s", pathbname);
+			else
+				error = asprintf(&pathname, "%s/%s",
+						    pathdnamer, pathbname);
+			if (error < 0) {
+				free(basename_cpy);
+				goto oom;
+			}
+		}
+		free(basename_cpy);
+	} else {
+		pathname = strdup(pathname_orig);
+		if (!pathname)
+			goto oom;
+	}
+
+	paths[0] = pathname;
+
+	if (lstat(pathname, &sb) < 0) {
+		if (state.flags.ignore_noent && errno == ENOENT) {
+			free(pathdnamer);
+			free(pathname);
+			return 0;
+		} else {
+			selinux_log(SELINUX_ERROR,
+				    "lstat(%s) failed: %m\n",
+				    pathname);
+			error = -1;
+			goto cleanup;
+		}
+	}
+
+	/* Skip digest if not a directory */
+	if (!S_ISDIR(sb.st_mode))
+		state.setrestorecondigest = false;
+
+	if (!state.flags.recurse) {
+		if (check_excluded(pathname)) {
+			error = 0;
+			goto cleanup;
+		}
+
+		error = usec_restorecon_sb(pathname, &sb, &state.flags, true, attr_name);
+		goto cleanup;
+	}
+
+	/* Obtain fs type */
+	memset(&state.sfsb, 0, sizeof(state.sfsb));
+	if (!S_ISLNK(sb.st_mode) && statfs(pathname, &state.sfsb) < 0) {
+		selinux_log(SELINUX_ERROR,
+			    "statfs(%s) failed: %m\n",
+			    pathname);
+		error = -1;
+		goto cleanup;
+	}
+
+	/* Skip digest on in-memory filesystems and /sys */
+	if (state.sfsb.f_type == RAMFS_MAGIC || state.sfsb.f_type == TMPFS_MAGIC ||
+	    state.sfsb.f_type == SYSFS_MAGIC)
+		state.setrestorecondigest = false;
+
+	if (state.flags.set_xdev)
+		fts_flags = FTS_PHYSICAL | FTS_NOCHDIR | FTS_XDEV;
+	else
+		fts_flags = FTS_PHYSICAL | FTS_NOCHDIR;
+
+	state.fts = fts_open(paths, fts_flags, NULL);
+	if (!state.fts)
+		goto fts_err;
+
+	state.ftsent_first = fts_read(state.fts);
+	if (!state.ftsent_first)
+		goto fts_err;
+
+	/*
+	 * Keep the inode of the first device. This is because the FTS_XDEV
+	 * flag tells fts not to descend into directories with different
+	 * device numbers, but fts will still give back the actual directory.
+	 * By saving the device number of the directory that was passed to
+	 * selinux_restorecon() and then skipping all actions on any
+	 * directories with a different device number when the FTS_XDEV flag
+	 * is set (from http://marc.info/?l=selinux&m=124688830500777&w=2).
+	 */
+	state.dev_num = state.ftsent_first->fts_statp->st_dev;
+
+	if (nthreads == 1) {
+		state.parallel = false;
+		usec_restorecon_thread(&state);
+	} else {
+		size_t i;
+		pthread_t self = pthread_self();
+		pthread_t *threads = NULL;
+
+		pthread_mutex_init(&state.mutex, NULL);
+
+		threads = calloc(nthreads - 1, sizeof(*threads));
+		if (!threads)
+			goto oom;
+
+		state.parallel = true;
+		/*
+		 * Start (nthreads - 1) threads - the main thread is going to
+		 * take part, too.
+		 */
+		for (i = 0; i < nthreads - 1; i++) {
+			if (pthread_create(&threads[i], NULL,
+                usec_restorecon_thread, &state)) {
+				/*
+				 * If any thread fails to be created, just mark
+				 * it as such and let the successfully created
+				 * threads do the job. In the worst case the
+				 * main thread will do everything, but that's
+				 * still better than to give up.
+				 */
+				threads[i] = self;
+			}
+		}
+
+		/* Let's join in on the fun! */
+		usec_restorecon_thread(&state);
+
+		/* Now wait for all threads to finish. */
+		for (i = 0; i < nthreads - 1; i++) {
+			/* Skip threads that failed to be created. */
+			if (pthread_equal(threads[i], self))
+				continue;
+			pthread_join(threads[i], NULL);
+		}
+		free(threads);
+
+		pthread_mutex_destroy(&state.mutex);
+	}
+
+	error = state.error;
+	if (state.saved_errno)
+		goto out;
+
+	/*
+	 * Labeling successful. Write partial match digests for subdirectories.
+	 * TODO: Write digest upon FTS_DP if no error occurs in its descents.
+	 * Note: we can't ignore errors here that we've masked due to
+	 * SELINUX_RESTORECON_COUNT_ERRORS.
+	 */
+	if (state.setrestorecondigest && !state.flags.nochange && !error &&
+	    state.skipped_errors == 0) {
+		current = state.head;
+		while (current != NULL) {
+			if (setxattr(current->path,
+			    RESTORECON_PARTIAL_MATCH_DIGEST,
+			    current->digest,
+			    SHA1_HASH_SIZE, 0) < 0) {
+				selinux_log(SELINUX_ERROR,
+					    "setxattr failed: %s: %m\n",
+					    current->path);
+			}
+			current = current->next;
+		}
+	}
+
+	skipped_errors = state.skipped_errors;
+
+out:
+	if (state.flags.progress && state.flags.mass_relabel)
+		fprintf(stdout, "\r%s 100.0%%\n", pathname);
+
+	(void) fts_close(state.fts);
+	errno = state.saved_errno;
+cleanup:
+	if (state.flags.add_assoc) {
+		if (state.flags.verbose)
+			filespec_eval();
+		filespec_destroy();
+	}
+	free(pathdnamer);
+	free(pathname);
+
+	current = state.head;
+	while (current != NULL) {
+		struct dir_hash_node *next = current->next;
+
+		free(current->path);
+		free(current);
+		current = next;
+	}
+	return error;
+
+oom:
+	selinux_log(SELINUX_ERROR, "%s:  Out of memory\n", __func__);
+	error = -1;
+	goto cleanup;
+
+realpatherr:
+	selinux_log(SELINUX_ERROR,
+		    "usec: Could not get canonical path for %s restorecon: %m.\n",
+		    pathname_orig);
+	error = -1;
+	goto cleanup;
+
+fts_err:
+	selinux_log(SELINUX_ERROR,
+		    "fts error while labeling %s: %m\n",
+		    paths[0]);
+	error = -1;
+	goto cleanup;
+}
+
 
 /*
  * Public API
@@ -1386,6 +2068,14 @@ int selinux_restorecon_parallel(const ch
 	return selinux_restorecon_common(pathname_orig, restorecon_flags, nthreads);
 }
 
+/* selinux_restorecon_parallel(3) - Parallel version of selinux_restorecon(3) */
+int usec_restorecon_parallel(const char *pathname_orig,
+    unsigned int restorecon_flags,
+    size_t nthreads, const char* attr_name)
+{
+    return usec_restorecon_common(pathname_orig, restorecon_flags, nthreads, attr_name);
+}
+
 /* selinux_restorecon_set_sehandle(3) is called to set the global fc handle */
 void selinux_restorecon_set_sehandle(struct selabel_handle *hndl)
 {
Index: libselinux/src/selinuxswig_python_exception.i
===================================================================
--- libselinux.orig/src/selinuxswig_python_exception.i
+++ libselinux/src/selinuxswig_python_exception.i
@@ -255,6 +255,16 @@
   }
 }
 
+
+%exception usec_lgetfilecon_raw {
+    $action
+    if (result < 0) {
+       PyErr_SetFromErrno(PyExc_OSError);
+       SWIG_fail;
+    }
+  }
+  
+
 %exception setfilecon {
   $action
   if (result < 0) {
Index: libselinux/include/selinux/selinux.h
===================================================================
--- libselinux.orig/include/selinux/selinux.h
+++ libselinux/include/selinux/selinux.h
@@ -12,6 +12,7 @@ extern "C" {
 extern int is_selinux_enabled(void);
 /* Return 1 if we are running on a SELinux MLS kernel, or 0 otherwise. */
 extern int is_selinux_mls_enabled(void);
+int is_selinux_enabled_raw(void);
 
 /* No longer used; here for compatibility with legacy callers. */
 typedef char *security_context_t
@@ -114,6 +115,12 @@ extern int lgetfilecon_raw(const char *p
 extern int fgetfilecon(int fd, char ** con);
 extern int fgetfilecon_raw(int fd, char ** con);
 
+extern int usec_getfilecon_raw(const char *path, const char* attr_name, char ** con);
+extern int usec_getfilecon(const char *path, const char* attr_name, char** con);
+extern int usec_lgetfilecon_raw(const char *path, const char* attr_name, char** con);
+extern int usec_lgetfilecon(const char *path, const char* attr_name, char** con);
+extern int usec_lsetfilecon_raw(const char *path, const char* attr_name, const char* con);
+
 /* Set file context */
 extern int setfilecon(const char *path, const char * con);
 extern int setfilecon_raw(const char *path, const char * con);
Index: libselinux/include/selinux/restorecon.h
===================================================================
--- libselinux.orig/include/selinux/restorecon.h
+++ libselinux/include/selinux/restorecon.h
@@ -37,7 +37,10 @@ extern int selinux_restorecon(const char
 extern int selinux_restorecon_parallel(const char *pathname,
 				       unsigned int restorecon_flags,
 				       size_t nthreads);
-/*
+extern int usec_restorecon_parallel(const char *pathname_orig,
+                        unsigned int restorecon_flags,
+                        size_t nthreads, const char* attr_name);
+                       /*
  * restorecon_flags options
  */
 /*
